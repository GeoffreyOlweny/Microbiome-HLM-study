---
title: "TB-Profiling Analysis"
author: "Geoffrey Olweny"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  word_document:
    toc: yes
    toc_depth: '3'
  html_document:
    df_print: paged
    theme: cerulean
    highlight: haddock
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: yes
    code_fold: show
---

```{r set up, include=FALSE}
path <- './'
knitr::opts_chunk$set(
  collapse = TRUE, 
  echo=TRUE,
  comment="#>", 
  message=FALSE,
  warning=FALSE,
	fig.align="center",
  fig.width=7,
  fig.height=5,
  dpi=600)
knitr::opts_knit$set(root.dir = path)
```


# **Install necessary packages required**
These are packages to be used in the analysis.

```{r, results='hide', warning=FALSE, message=FALSE}
# List of CRAN packages
cran_packages <- c(
  "ggplot2", "pgirmess", "reshape", "dplyr", "tidyverse", "rstatix", 
  "ggpubr", "cowplot", "RColorBrewer", "fs", "vegan", "ggsignif", "ggtreeExtra", 
  "ggstar", "ggalluvial", "ggtree", "patchwork", "randomForest", 
  "caret", "ROCR", "e1071", "gridExtra", "fastDummies", "here", "pROC"
)
# List of Bioconductor packages
bioc_packages <- c(
  "metadeconfoundR", "DirichletMultinomial", "phyloseq", "edgeR", "MicrobiotaProcess"
)

# Function to check if a package is installed, and if not, install it
install_if_missing_cran <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
  }
}

# Function to check if a Bioconductor package is installed, and if not, install it
install_if_missing_bioc <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    BiocManager::install(pkg)
  }
}

# Apply the function to each CRAN package
lapply(cran_packages, install_if_missing_cran)

# Apply the function to each Bioconductor package
lapply(bioc_packages, install_if_missing_bioc)

# Install EasyStat from Git
if (!requireNamespace("EasyStat", quietly = TRUE)) {
  remotes::install_git('https://gitee.com/wentaomicro/EasyStat')
}

# Install ggClusterNet from GitHub
if (!requireNamespace("ggClusterNet", quietly = TRUE)) {
  remotes::install_github("taowenmicro/ggClusterNet")
}

# Load all the packages
all_packages <- c(cran_packages, bioc_packages, "EasyStat", "ggClusterNet")
lapply(all_packages, library, character.only = TRUE)


```


# **Load the necessary packages**
These are to be used during analysis.

```{r, results='hide', warning=FALSE, message=FALSE}
# Load required libraries
library(metadeconfoundR)
library(DirichletMultinomial)
library(phyloseq)  
library(ggplot2)   
library(pgirmess)  
library(reshape) 
library(dplyr) 
library(tidyverse)
library(rstatix)
library(ggpubr)
library(cowplot)
library(fs)
library(vegan)
library(ggClusterNet)
library(EasyStat)
library(ggsignif)
library(ggtreeExtra)
library(ggstar)
library(ggalluvial)
library(ggtree)
library(patchwork)
library(edgeR)
library(randomForest)
library(caret)
library(ROCR) 
library(e1071)
library(MicrobiotaProcess)
library(gridExtra)
library(fastDummies)  
library(RColorBrewer) 
library(here)

sessionInfo()

```


# **Reading in the Files**
These are input files required for the protocol.

```{r, results="hide"}
# Load OTU counts files
Genexpert_otu_df <- read.table("data/Genexpert_OTU.txt", header = TRUE, row.names = 1)
MtbInfectionStatus_otu_df <- read.table("data/MtbInfectionStatus_OTU.txt", header = TRUE, row.names = 1)
# Load taxonomy table
tax_df <- read.table("data/Tax.txt", header = TRUE, sep = "\t", row.names = 1, check.names = FALSE)
# Replace all "?" values in tax_df with "Unknown"
tax_df[tax_df == "?"] <- "Unknown"
# Load metadata files
Genexpert_metadata_df <- read.csv(file = "data/Genexpert_metadata.csv", header = TRUE, row.names = 1)
MtbInfectionStatus_metadata_df <- read.csv(file = "data/MtbInfectionStatus_metadata.csv", header = TRUE, row.names = 1)
```

## **Inspect files**
```{r}

# Inspect the first few rows of Genexpert OTU counts
head(Genexpert_otu_df)

# Inspect the first few rows of Mtb Infection Status OTU counts
head(MtbInfectionStatus_otu_df)

# Inspect the first few rows of the taxonomy table
head(tax_df)

# Inspect the first few rows of Genexpert metadata
head(Genexpert_metadata_df)

# Inspect the first few rows of Mtb Infection Status metadata
head(MtbInfectionStatus_metadata_df)

```

## **Convert each OTU, Taxonomy and Metadata file into a matrix**

```{r}
# Create the OTU table for Genexpert samples
Genexpert_OTU <- otu_table(Genexpert_otu_df, taxa_are_rows = TRUE)

# Create the OTU table for Mtb Infection Status samples
MtbInfectionStatus_OTU <- otu_table(MtbInfectionStatus_otu_df, taxa_are_rows = TRUE)

# Create the taxonomy table
TAX <- phyloseq::tax_table(as.matrix(tax_df))

# Create the sample data for Genexpert samples
Genexpert_SAM <- sample_data(Genexpert_metadata_df)

# Create the sample data for Mtb Infection Status samples
MtbInfectionStatus_SAM <- sample_data(MtbInfectionStatus_metadata_df)

```

## **Create phyloseq object**
This is an S4 object required for downstream analysis.
```{r}

# Create the phyloseq object for Genexpert samples
Genexpert_phyloseq <- phyloseq(Genexpert_OTU, TAX, Genexpert_SAM)

# Create the phyloseq object for Mtb Infection Status samples
MtbInfectionStatus_phyloseq <- phyloseq(MtbInfectionStatus_OTU, TAX, MtbInfectionStatus_SAM)


```

### **Inspect the phyloseq object**
```{r}
# Inspect the Genexpert phyloseq object
Genexpert_phyloseq

# Inspect the Mtb Infection Status phyloseq object
MtbInfectionStatus_phyloseq

```
### **Save phyloseq objects**
```{r}

# Save Genexpert_physeq as an RDS file
saveRDS(Genexpert_phyloseq, file = "data/Genexpert_physeq.rds")

# Save MtbInfectionStatus_physeq as an RDS file
saveRDS(MtbInfectionStatus_phyloseq, file = "data/MtbInfectionStatus_physeq.rds")
```
# **Diversity metrices**
## **Alpha diversity**
```{r, results='hide', warning=FALSE, message=FALSE}
metrics <- c("Shannon", "Observed", "Chao1", "Simpson", "Fisher", "ACE")
pal.Coll <- c("darkblue", "coral", "darkgreen")

# Estimate richness for Genexpert data
alpha_metrics_Group <- estimate_richness(Genexpert_phyloseq, measures = metrics)

# Estimate richness for MtbStatus data
alpha_metrics_MtbStatus <- estimate_richness(MtbInfectionStatus_phyloseq, measures = metrics)

# Combine Genexpert metadata with richness estimates and adjust the Group variable
alpha_metrics_df_Group <- cbind(Genexpert_metadata_df, alpha_metrics_Group)
alpha_metrics_df_Group$Group <- as.factor(alpha_metrics_df_Group$Group)

# Combine MtbStatus metadata with richness estimates and adjust the Group variable
alpha_metrics_df_MtbStatus <- cbind(MtbInfectionStatus_metadata_df, alpha_metrics_MtbStatus)
alpha_metrics_df_MtbStatus$Group <- as.factor(alpha_metrics_df_MtbStatus$Group)

```

### **Function for generating Mtb Infection status plots**
```{r, warning=FALSE, message=FALSE}
# Function to generate a plot for a given metric
generate_plot <- function(metric) {
  # Perform Wilcoxon test on the metric grouped by 'Group', adjust p-values using BH method,
  # add significance and position information
  stats_test <- alpha_metrics_df_MtbStatus %>%
    rstatix::wilcox_test(reformulate("Group", metric)) %>%
    rstatix::adjust_pvalue(method = "BH") %>%
    rstatix::add_significance() %>%
    rstatix::add_xy_position(x = "Group")
  
  # Create the plot
  plot <- alpha_metrics_df_MtbStatus %>%
    ggplot(aes(x = Group, y = .data[[metric]])) +
    geom_boxplot(color = "black", alpha = 0.5, outlier.shape = NA) +  # Add boxplot
    geom_point(position = position_jitter(0.2), size = 3, aes(fill = Group, color = Group)) +  # Add points with jitter
    scale_color_manual(values = pal.Coll) +  # Set manual color scale
    xlab("Group") +  # Label x-axis
    ylab(paste(metric, "Index")) +  # Label y-axis
    labs(caption = get_pwc_label(stats_test)) +  # Add caption with significance
    theme_bw() +  # Set theme to black and white
    theme(
      text = element_text(size = 10),  # Set text size
      axis.title.x = element_blank(),  # Remove x-axis title
      axis.text.x = element_blank(),  # Remove x-axis text
      axis.ticks.x = element_blank(),  # Remove x-axis ticks
      axis.text.x.bottom = element_text(size = 10, angle = 90),  # Set x-axis text at bottom with rotation
      legend.position = "none"  # Remove legend
    ) +
    stat_pvalue_manual(stats_test, bracket.nudge.y = -2, step.increase = 0.05, hide.ns = TRUE, tip.length = 0, label = "{p.adj.signif}")  # Add p-values manually
  
  # Return the plot and statistical test results as a list
  return(list(plot = plot, stats_test = stats_test))
}

```

### **Generate cow plot**
```{r, warning=FALSE, message=FALSE}
plots <- lapply(metrics, generate_plot)
names(plots) <- metrics
alpha_diversity_final <- cowplot::plot_grid(plotlist = lapply(plots, `[[`, "plot"))
# Add a title to the alpha_diversity_final plot
alpha_diversity_final <- ggdraw() +
  draw_plot(alpha_diversity_final, 0, 0, 1, 0.9) +  # Adjust plot size to leave space for title
  draw_label("Alpha Diversity According to Mtb Infection Status", 
             x = 0.5, y = 0.95, hjust = 0.5, size = 16, fontface = "bold")


```

### **View cow plot**
```{r, warning=FALSE, message=FALSE}
print(alpha_diversity_final)

ggsave(filename = "Results/Figure 1.jpg", 
       plot = alpha_diversity_final, 
       width = 10, height = 8, dpi = 600)
```

## **Beta diversity**
This is done using the Bray_Curtis dissimilarity matrix.

```{r, warning=FALSE, message=FALSE}
# Compute Bray-Curtis dissimilarity matrix and perform PCoA for Genexpert results
beta <- vegan::vegdist(t(Genexpert_otu_df), method = "bray", na.rm = TRUE)
beta[is.na(beta)] <- 0
pcoaE <- cmdscale(beta, k = 2) 
pcoaE <- as.data.frame(pcoaE) 
metadata_beta <- cbind(Genexpert_metadata_df, pcoaE) 
Group_metadata_beta <- metadata_beta
centroids <- aggregate(cbind(V1, V2) ~ Group, metadata_beta, mean)
# Compute Bray-Curtis dissimilarity matrix and perform PCoA for Mtb Infection status
beta <- vegan::vegdist(t(MtbInfectionStatus_otu_df), method = "bray", na.rm = TRUE)  # Compute Bray-Curtis dissimilarity
beta[is.na(beta)] <- 0  # Replace any NA values with 0
pcoaE <- cmdscale(beta, k = 2)  # Perform PCoA, reducing to 2 dimensions
pcoaE <- as.data.frame(pcoaE)  # Convert PCoA result to a data frame
metadata_beta <- cbind(MtbInfectionStatus_metadata_df, pcoaE)  # Combine metadata with PCoA results
centroids <- aggregate(cbind(V1, V2) ~ Group, metadata_beta, mean)  # Calculate centroids for each group

# Plot PCoA with points colored by Group
metadata_beta %>%
  ggplot(aes(x = V1, y = V2, color = Group)) +  # PCoA plot by M.tb infection status
  theme_classic() + 
  scale_color_manual(values = pal.Coll) +  # Set custom colors for groups
  geom_point(aes(color = Group), size = 5, alpha = 0.8) +  # Plot points with transparency
  xlab("PCo 1") + ylab("PCo 2") +  # Label axes
  theme(axis.title.x = element_text(size = 13), 
        axis.text.x = element_text(size = 13), 
        axis.text.y = element_text(size = 13), 
        axis.title.y = element_text(size = 13),
        legend.position = "bottom",  # Position the legend on the bottom
        legend.title = element_text(size = 12),  # Set title size for legend
        legend.text = element_text(size = 10)) +  # Set text size for legend
  labs(color = "M.tuberculosis Infection Status") +  # Set legend title
  stat_ellipse(aes(color = Group)) +  # Add ellipses to show group clusters
  geom_point(data = centroids, size = 5, shape = 16, color = "black") + # Add centroids in black
  geom_point(data = centroids, size = 4, shape = 16) -> B  # Overlay centroids with group color

# Add density plot for V1 (first PCoA axis)
xdensity <- metadata_beta %>%
  ggplot(aes(x = V1)) +
  geom_density(alpha = 0.5, aes(fill = Group, color = Group)) +  # Create density plot
  scale_fill_manual(values = pal.Coll) +  # Set manual fill colors
  scale_color_manual(values = pal.Coll) +  # Set manual line colors
  theme_classic() +  # Apply classic theme for a clean look
  theme(
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.ticks.x = element_blank(),  # Remove x-axis ticks
    axis.line.x = element_blank(),  # Remove x-axis line
    axis.text.y = element_blank(),  # Remove y-axis text
    axis.ticks.y = element_blank(),  # Remove y-axis ticks
    legend.position = "none"  # Hide legend
  )

# Add density plot for V2 (second PCoA axis)
ydensity <- metadata_beta %>%
  ggplot(aes(V2)) +
  geom_density(alpha = 0.5, aes(fill = Group, color = Group)) +  # Create density plot for V2 colored by Group
  scale_fill_manual(values = pal.Coll) +  # Set manual fill colors
  scale_color_manual(values = pal.Coll) +  # Set manual line colors
  theme_classic() +  # Apply classic theme for a clean look
  theme(
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.ticks.x = element_blank(),  # Remove x-axis ticks
    axis.title.y = element_blank(),  # Remove y-axis title
    axis.text.y = element_blank(),  # Remove y-axis text
    axis.ticks.y = element_blank(),  # Remove y-axis ticks
    axis.line.y = element_blank(),  # Remove y-axis line
    legend.position = "none"  # Hide legend
  ) +
  coord_flip()  # Flip coordinates for a vertical plot

# Create a blank plot for spacing
blankPlot <- ggplot() + geom_blank(aes(1,1)) + theme_void()

# Create a combined plot with legend at the bottom
beta_final <- plot_grid(
  xdensity + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),  # Add x-density plot with no margins
  blankPlot + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),  # Add a blank plot with no margins
  B + theme(legend.position = "bottom",  # Add the main plot B with legend at the bottom
            plot.margin = unit(c(0, 0, 0, 0), "cm")),  
  ydensity + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),  # Add y-density plot with no margins
  nrow = 2,  # Arrange plots in a 2-row grid
  rel_widths = c(4, 1.4),  # Set relative widths for columns
  rel_heights = c(1.4, 4),  # Set relative heights for rows
  align = "hv"  # Align plots both horizontally and vertically
)
# Load cowplot package
library(cowplot)

# Add a title to the beta_final plot
beta_final <- ggdraw() +
  draw_plot(beta_final, 0, 0, 1, 0.9) +  # Adjust the plot size to leave space for the title
  draw_label("Beta Diversity According to Mtb Infection Status", 
             x = 0.5, y = 0.95, hjust = 0.5, size = 16, fontface = "bold")
# Display the final plot
print(beta_final)

# Perform PERMANOVA test to compare beta diversity between 'TB_history' groups
# Compute Bray-Curtis dissimilarity matrix from OTU data
permanova <- adonis2(vegdist(t(MtbInfectionStatus_otu_df), method = "bray", na.rm = TRUE) ~ as.factor(Group), data = metadata_beta)

# Convert PERMANOVA results to a data frame
permanova <- as.data.frame(permanova)

# Save the data frame to a CSV file
write.csv(permanova, file = "Results/Mtb_infection status_permanova_results.csv", row.names = TRUE)

ggsave(filename = "Results/Figure 2.jpg", 
       plot = beta_final, 
       width = 10, height = 8, dpi = 600)
```

# **DMM**
The models help identify underlying community structures by partitioning the data into distinct groups based on microbial abundance profiles. DMM utilizes an Infinite mixture model; hence, it can infer the optimal number of microbiome microbial community types.

```{r, warning=FALSE, message=FALSE}
# Read in the Genus abundance table
genus <- read.table("data/Genus.txt", header = TRUE, row.names = NULL, sep = "\t")

# Assign tax column as row names and remove the tax column from the data frame
rownames(genus) <- genus$Genus
genus <- subset(genus, select = -Genus)

# Ensure row names are unique
unique_row_names <- make.names(row.names(genus), unique = TRUE)
row.names(genus) <- unique_row_names

# Create a copy of genus called raw
raw <- genus

# Transpose the data frame and remove columns with zero sums
raw_values <- t(raw)  # Transpose the data frame
raw_values <- raw_values[, colSums(raw_values) > 0]  # Remove columns with zero sums
raw_values_t <- t(raw_values)  # Transpose back to the original orientation

# Note that genus_table has samples as columns and genera as rows
genus_table <- as.data.frame(raw_values_t)

# Create a data frame with the row names of genus_table
genus_p <- as.data.frame(row.names(genus_table))

# Rename the column to 'long_names'
colnames(genus_p) <- "long_names"

# Separate the long names into multiple columns based on the dot separator
tax_names <- tidyr::separate(
  genus_p, 
  long_names, 
  into = c("A", "B", "C", "D", "E", "F"), 
  sep = "\\.", 
  fill = "right",  # Fill missing values with NA on the right side
  extra = "drop"   # Drop any extra columns beyond what is specified
)

# Add the genus names (last part after the last dot) to genus_table
genus_table$short <- tax_names$F

# Make these genus names unique and set them as row names for genus_table
row.names(genus_table) <- make.names(genus_table$short, unique = TRUE)

# Remove the 'short' column from genus_table since it's now redundant
genus_table$short <- NULL

# Normalize genus_table
genus_table <- genus_table / min(genus_table[genus_table > 0])

# Set the maximum number of Dirichlet components to check
all_dmns <- 6 

# Initialize a list to store the Dirichlet models
dmn_list <- vector("list", all_dmns)

# Fit Dirichlet Multinomial models with components ranging from 1 to all_dmns
for (i in 1:all_dmns) {
  print(i)  # Print the current number of components being processed
  dmn_list[[i]] <- dmn(as.matrix(t(genus_table)), i, verbose = FALSE)  # Fit the model and store it in the list
}

# Calculate Laplace, BIC, and AIC for each Dirichlet Multinomial model
lplc <- sapply(dmn_list, laplace)
BIC <- sapply(dmn_list, BIC)
AIC <- sapply(dmn_list, AIC)

# Plot Laplace, BIC, and AIC values
plot(lplc, type = "b", xlab = "Number of Dirichlet Components", ylab = "Laplace")
plot(BIC, type = "b", xlab = "Number of Dirichlet Components", ylab = "BIC")
plot(AIC, type = "b", xlab = "Number of Dirichlet Components", ylab = "AIC")

# Find the model with the minimum Laplace value
best_lplc_index <- which.min(lplc)
optimal_lplc_model <- dmn_list[[best_lplc_index]]
print(optimal_lplc_model)

# Find the model with the minimum BIC value
best_BIC_index <- which.min(BIC)
optimal_BIC_model <- dmn_list[[best_BIC_index]]
print(optimal_BIC_model)

# Find the model with the minimum AIC value
best_AIC_index <- which.min(AIC)
optimal_AIC_model <- dmn_list[[best_AIC_index]]
print(optimal_AIC_model)

# Assign the best model based on the minimum Laplace value as the final model
best_fit <- dmn_list[[best_lplc_index]]

# Get the cluster importance from the best model
cluster_imp <- fitted(best_fit)  # Extract cluster importance

# Print the cluster importance
print(cluster_imp)

# Extract fitted values from the models
p1 <- fitted(dmn_list[[1]], scale = TRUE)  # Fitted values from the first model
p5 <- fitted(best_fit, scale = TRUE)  # Fitted values from the best model

# Compute the mean difference
meandiff <- colSums(abs(p5 - as.vector(p1)))

# Display the mean difference
print(meandiff)

# Extract the fitted values from the best model
x <- mixture(best_fit)

# Initialize an empty list to store plots
plot_list <- vector("list", ncol(fitted(best_fit)))

# Loop through each cluster
for (k in seq(ncol(fitted(best_fit)))) {
  # Melt the fitted values to long format
  d <- melt(fitted(best_fit))
  colnames(d) <- c("OTU", "cluster", "value")  # Rename columns
  # Filter and process data for the current cluster
  d <- subset(d, cluster == k) %>%
    arrange(value) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
    filter(abs(value) > quantile(abs(value), 0.8))  # Keep top 20% most significant OTUs
  
  # Define a function to generate color hues
  gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  
  # Get colors for the bars
  cols = gg_color_hue(ncol(fitted(best_fit)))
  
  # Create the plot for the current cluster
  p <- ggplot(d[(length(d$value) - 10):length(d$value), ],
              aes(x = OTU, y = value)) +
    xlab("") +  # Remove x-axis label
    ylab("Cluster load") +  # Label y-axis
    geom_bar(stat = "identity", fill = cols[k], colour = "black") +  # Bar plot with color and border
    coord_flip() +  # Flip coordinates for horizontal bars
    theme_classic() +  # Apply classic theme
    theme(axis.text.y = element_text(face = "italic"),  # Style y-axis text
          axis.text = element_text(size = 13, face = 'bold'),  # Style axis text
          axis.title = element_text(size = 15, face = 'bold'))  # Style axis titles
  
  # Store the plot in the list
  plot_list[[k]] <- p
}

# Combine and display all plots in plot_list
combined_plot<- grid.arrange(grobs = plot_list, ncol = 2)
# Create the combined plot with cowplot and add a title
combined_plot <- ggdraw() +
  draw_plot(combined_plot, 0, 0, 1, 0.9) +  # Adjust plot size to leave space for title
  draw_label("DMM Microbial Communities/Pulmotypes", 
             x = 0.5, y = 0.95, hjust = 0.5, size = 16, fontface = "bold")
print(combined_plot)
ggsave("Results/Figure 3.jpg", plot = combined_plot, dpi = 600, width = 12, height = 8)


```

## **Cofounding factors between microbiome alpha diversity metrics and the different DMM microbial communities**
```{r, warning=FALSE, message=FALSE}
alpha_features <- alpha_metrics_df_Group


meta_alpha_decon <- Genexpert_metadata_df

# Fit Dirichlet Multinomial models with components ranging from 1 to all_dmns
dmn_list <- lapply(1:all_dmns, function(k) dmn(as.matrix(t(genus_table)), k, verbose = FALSE))

# Determine the best model (based on Laplace)
best_fit_index <- best_lplc_index  
best_fit <- dmn_list[[best_fit_index]]

# Assign clusters for the best fit Dirichlet model
cluster_result <- as.data.frame(mixture(best_fit, assign = TRUE))
cluster_col_name <- paste0("Dirichlet_multinomial_k=", best_fit_index)
colnames(cluster_result) <- cluster_col_name

# Add the cluster results to meta_alpha_decon
meta_alpha_decon <- cbind(meta_alpha_decon, cluster_result)

# Update cluster labels to descriptive names
cluster_levels <- unique(meta_alpha_decon[[cluster_col_name]])
cluster_labels <- paste("Type", cluster_levels)
meta_alpha_decon[[cluster_col_name]] <- factor(
  meta_alpha_decon[[cluster_col_name]], 
  levels = cluster_levels, 
  labels = cluster_labels
)

# Add a new column 'smpl' with row names
meta_alpha_decon$smpl <- row.names(meta_alpha_decon)

# Create dummy columns for the selected cluster column
meta_alpha_decon <- fastDummies::dummy_cols(.data = meta_alpha_decon, select_columns = cluster_col_name)

# Set the row names of 'meta_alpha_decon' to the 'smpl' column and clean up
row.names(meta_alpha_decon) <- meta_alpha_decon$smpl
meta_alpha_decon$smpl <- NULL
meta_alpha_decon[[cluster_col_name]] <- NULL

# Order the dataframes by row names
alpha_features <- alpha_features[order(rownames(alpha_features)), ]
meta_alpha_decon <- meta_alpha_decon[order(rownames(meta_alpha_decon)), ]
# Recode the values in the Group column in both dataframes
meta_alpha_decon$Group[meta_alpha_decon$Group == "Xpert-ve"] <- 0
meta_alpha_decon$Group[meta_alpha_decon$Group == "Xpert+ve"] <- 1

# Replace values in Group column
alpha_features$Group <- ifelse(alpha_features$Group == "Xpert-ve", 0, 
                                       ifelse(alpha_features$Group == "Xpert+ve", 1, alpha_features$Group))

#Run metadecofound function
meta_alpha_out <- metadeconfoundR::MetaDeconfound(
  featureMat = alpha_features,
  metaMat = meta_alpha_decon,
  nnodes = 4,  # Number of nodes to use for parallel processing
  logfile = here::here("MetadeconfoundR_feature_alpha.log")  # Path to the log file
)
#Heatmap
alpha_metaDR <- metadeconfoundR::BuildHeatmap(
  meta_alpha_out,
  d_col = c("blue", "white", "red"),  # Color scheme for the heatmap
  d_range = "full"  # Use the full range of the data for color scaling
)
alpha_metaDR1 <- alpha_metaDR +
  theme(axis.text.y = element_text(face ="italic"))
# Add a title to the alpha_metaDR1 plot
alpha_metaDR1 <- alpha_metaDR1 +
  ggtitle("Confounding Status of DMM Microbial Community Types on Alpha Diversity Metrics") +
  theme(plot.title = element_text(hjust = 0.5, size = 12))  # Center and size the title

print(alpha_metaDR1)
ggsave("Results/Figure 4.jpg",alpha_metaDR1, width = 8, height =8,limitsize = FALSE, dpi=600)


```
## **Beta diversity of the different DMM microbial community types/pulmotypes**

```{r, warning=FALSE, message=FALSE}
# Create cluster results and combine with metadata

# Add the cluster results to metadata_beta
metadata_beta <- cbind(Group_metadata_beta, cluster_result)
metadata_beta[[cluster_col_name]] <- as.character(metadata_beta[[cluster_col_name]])

# Calculate centroids for the clusters
centroids <- aggregate(cbind(V1, V2) ~ ., data = metadata_beta, FUN = mean)

# Define custom colors for the plot
ComCol <- c("chartreuse3", "deepskyblue2", "red3", "purple","orange","violet")

# Create the main plot with points and ellipses
Bcluster <- metadata_beta %>%
  ggplot(aes(x = V1, y = V2, color = .data[[cluster_col_name]])) +
  theme_classic() +
  scale_color_manual(values = ComCol) +
  geom_point(size = 5, alpha = 0.8) +
  xlab("PCo 1") + ylab("PCo 2") +
  labs(color = "Microbial Community types") +
  theme(axis.title.x = element_text(size = 13),
        axis.text.x = element_text(size = 13),
        axis.text.y = element_text(size = 13),
        axis.title.y = element_text(size = 13),
        legend.position = "bottom") +
  stat_ellipse() +
  geom_point(data = centroids, size = 5, shape = 16, color = "black") +
  geom_point(data = centroids, size = 4, shape = 21, fill = "white")

#Create the x-axis density plot
xdensity <- metadata_beta %>%
  ggplot(aes(x = V1, fill = .data[[cluster_col_name]], color = .data[[cluster_col_name]])) +
  geom_density(alpha = .5) +
  scale_fill_manual(values = ComCol) +
  scale_color_manual(values = ComCol) +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")

#Create the y-axis density plot with flipped coordinates
ydensity <- metadata_beta %>%
  ggplot(aes(x = V2, fill = .data[[cluster_col_name]], color = .data[[cluster_col_name]])) +
  geom_density(alpha = .5) +
  scale_fill_manual(values = ComCol) +
  scale_color_manual(values = ComCol) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank(),
        legend.position = "none") +
  coord_flip()

#Create a blank plot for layout purposes
blankPlot <- ggplot() +
  geom_blank(aes(1, 1)) +
  theme_void()

#Combine the plots into a single grid layout
Beta_diversity <- 
  cowplot::plot_grid(
    xdensity + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),
    blankPlot + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),
    Bcluster + theme(legend.position = "bottom",
                     plot.margin = unit(c(0, 0, 0, 0), "cm")),
    ydensity + theme(plot.margin = unit(c(0, 0, 0, 0), "cm")),
    nrow = 2,
    rel_widths = c(1, 0.5),
    rel_heights = c(0.5, 1),
    align = "hv"
  )
# Add a title to the Beta_diversity plot
Beta_diversity <- cowplot::ggdraw() +
  cowplot::draw_plot(Beta_diversity, 0, 0, 1, 0.9) +  # Adjust plot position and size
  cowplot::draw_label("Beta Diversity of DMM Microbial Community Types", 
                      x = 0.5, y = 0.95, hjust = 0.5, size = 16)

# Display the combined plot
print(Beta_diversity)
ggsave("Results/Figure 5.jpg",Beta_diversity, width = 8, height =8,limitsize = FALSE, dpi=600)

```

# **Relative abundance** 
## **Phylum**
```{r, warning=FALSE, message=FALSE}
# Custom theme for plots
custom_theme <- ggplot2::theme_bw() + 
  ggplot2::theme(
    panel.background = ggplot2::element_blank(),  # Remove background color
    panel.grid = ggplot2::element_blank(),  # Remove grid lines
    legend.position = "right",  # Position legend on the right
    legend.title = ggplot2::element_blank(),  # Remove legend title
    legend.background = ggplot2::element_blank(),  # Remove legend background
    legend.key = ggplot2::element_blank(),  # Remove legend key background
    plot.title = ggplot2::element_text(vjust = -8.5, hjust = 0.1),  # Adjust plot title position
    axis.title.y = ggplot2::element_text(colour = "black"),  # Set Y axis title color
    axis.text = ggplot2::element_text()  # Set axis text style
  )
# Color palette for plots
color_set <- c(RColorBrewer::brewer.pal(11, "Set1"), RColorBrewer::brewer.pal(9, "Pastel1"))
# Assign the phyloseq object to a variable
phyloseq_object <- MtbInfectionStatus_phyloseq 
group_col <- "Group"  # Define the group column name
rank <- "Phylum"  # Define the taxonomic rank
add_labels <- TRUE  # Flag to add labels
show_sd <- FALSE  # Flag to show standard deviation
top_n <- 10  # Number of top taxa to include
transform_abundance <- TRUE  # Flag to transform data to relative abundance

# Get unique levels for group column
axis_order <- phyloseq::sample_data(phyloseq_object)$Group %>% unique()

# Perform taxonomic glomming (grouping)
phyloseq_data <- ggClusterNet::tax_glom_wt(ps = phyloseq_object, ranks = rank)
  
# Transform to relative abundance if specified
if (transform_abundance == TRUE) {
  phyloseq_data <- phyloseq_data %>%
    phyloseq::transform_sample_counts(function(x) {x / sum(x)})
}
  
# Extract OTU and taxonomy tables
otu_table <- phyloseq::otu_table(phyloseq_data)
tax_table <- phyloseq::tax_table(phyloseq_data)
  
# Adjust taxonomy table to group non-top taxa as "others"
for (i in 1:dim(tax_table)[1]) {
  if (row.names(tax_table)[i] %in% names(sort(rowSums(otu_table), decreasing = TRUE)[1:top_n])) {
    tax_table[i, rank] <- tax_table[i, rank]
  } else {
    tax_table[i, rank] <- "others"
  }
}
# Update the phyloseq object with the modified taxonomy table
phyloseq::tax_table(phyloseq_data) <- tax_table
  
# Melt the phyloseq object to a data frame
taxonomies <- phyloseq_data %>%
  phyloseq::psmelt()

# Convert abundance to percentage
taxonomies$Abundance <- taxonomies$Abundance * 100
# Rename taxonomy column to "taxonomy"
colnames(taxonomies) <- gsub(rank, "taxonomy", colnames(taxonomies))

# Initialize an empty data frame
final_data <- c()
# Loop over each group to calculate relative abundance
for (i in 1:length(unique(phyloseq::sample_data(phyloseq_object)$Group))) {
  group_name <- as.data.frame(table(phyloseq::sample_data(phyloseq_object)$Group))[i, 1]
  group_size <- as.data.frame(table(phyloseq::sample_data(phyloseq_object)$Group))[i, 2]

  # Filter data by group
  group_data <- taxonomies %>% 
    dplyr::filter(Group == group_name)
  group_data$Abundance <- group_data$Abundance / group_size
  
  # Create a temporary data frame for the current group
  temp_data <- data.frame(Sample = group_data$Sample, 
                          Abundance = group_data$Abundance, 
                          taxonomy = group_data$taxonomy, 
                          Group = group_data$Group)

  # Combine data for all groups
  if (i == 1) {
    final_data <- temp_data
  } else {
    final_data <- rbind(final_data, temp_data)
  }
}

# Update taxonomies data frame with combined data
taxonomies <- final_data

# Group data by taxonomy and group columns
grouped_taxa <- dplyr::group_by(taxonomies, taxonomy, Group)
# Summarize abundance and standard deviation by group and taxonomy
summarized_data <- dplyr::summarize(grouped_taxa, sum(Abundance), sd(Abundance))

# Group data by taxonomy to calculate total abundance
taxonomy_groups <- dplyr::group_by(taxonomies, taxonomy)
total_abundance <- dplyr::summarize(taxonomy_groups, sum(Abundance))
head(total_abundance)
# Rename columns for total abundance data
colnames(total_abundance) <- c("taxonomy", "total_sum")
# Arrange taxa by total abundance in descending order
total_abundance <- dplyr::arrange(total_abundance, desc(total_sum))
  
# Preview the summarized data
head(summarized_data)
# Rename columns in summarized data
colnames(summarized_data) <- c("taxonomy", "group", "Abundance", "sd")
# Convert taxonomy to a factor and order by total abundance
summarized_data$taxonomy <- factor(summarized_data$taxonomy, order = TRUE, levels = total_abundance$taxonomy)

# Copy summarized data for further processing
summarized_data_2 <- summarized_data

# Calculate cumulative sums for plotting labels
plot_data <- plyr::ddply(summarized_data_2, "group", summarize, label_sd = cumsum(Abundance), label_y = cumsum(Abundance) - 0.5 * Abundance)
head(plot_data)
  
# Combine summarized data with cumulative sum labels
plot_data <- cbind(as.data.frame(summarized_data_2), as.data.frame(plot_data)[, -1])

# Set label column to be the taxonomy
plot_data$label <- plot_data$taxonomy

# Order taxonomy levels by total abundance
plot_data$taxonomy <- factor(plot_data$taxonomy, order = TRUE, levels = c(as.character(total_abundance$taxonomy)))

# Create a bar plot for relative abundance
bar_plot <- ggplot(plot_data, aes(x = group, y = Abundance, fill = taxonomy, order = taxonomy)) +
  geom_bar(stat = "identity", width = 0.5, color = "black") +
  theme(axis.title.x = element_blank()) +
  theme(legend.text = element_text(size = 6)) +
  scale_y_continuous(name = "Relative abundance (%)") +
  guides(fill = guide_legend(title = rank)) +
  labs(x = "", y = "Relative abundance (%)", title = "")

# Adjust X-axis to follow the order of groups
bar_plot <- bar_plot + scale_x_discrete(limits = axis_order)

# Add error bars if the show_sd flag is TRUE
if (show_sd == TRUE) {
  bar_plot <- bar_plot +
    geom_errorbar(aes(ymin = label_sd - sd, ymax = label_sd + sd), width = 0.2)
}

# Convert sample data to a data frame
sample_data <- as.data.frame(phyloseq::sample_data(phyloseq_object))
# Adjust text angle on the X-axis if there are more than 3 groups
if (length(unique(sample_data$Group)) > 3) {
  bar_plot <- bar_plot + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
}

# Get the taxonomy levels
taxa <- plot_data$taxonomy
# Calculate the number of factor levels
num_factors <- taxa %>% levels() %>% length()

# Summarize the number of occurrences of each factor level
factor_summary <- taxa %>%
  as.factor() %>%
  summary() %>%
  as.data.frame()

# Add row names as an ID column
factor_summary$id <- row.names(factor_summary)

# Arrange factors by ID and data by taxonomy
arranged_factors <- dplyr::arrange(factor_summary, id)
arranged_plot_data <- dplyr::arrange(plot_data, taxonomy)
head(arranged_plot_data)
# Assign an ID to each row in the arranged plot data
arranged_plot_data$ID <- factor(rep(c(1:num_factors), factor_summary$.))

head(arranged_plot_data)
arranged_plot_data$Abundance

# Create an alluvial plot for relative abundance
alluvial_plot <- ggplot(arranged_plot_data, aes(x = group, y = Abundance, fill = taxonomy, alluvium = taxonomy, stratum = ID)) +
  ggalluvial::geom_flow(aes(fill = taxonomy, colour = taxonomy),
            stat = "alluvium", lode.guidance = "rightleft",
            color = "black", size = 0.2, width = 0.35, alpha = .2)  +
  geom_bar(width = 0.45, stat = "identity") +
  labs(x = "", y = "Relative abundance (%)", title = "") +
  guides(fill = guide_legend(title = rank), color = FALSE) +
  scale_y_continuous(expand = c(0, 0))

# Add error bars to the alluvial plot if the show_sd flag is TRUE
if (show_sd == TRUE) {
  alluvial_plot <- alluvial_plot +
    geom_errorbar(aes(ymin = label_sd - sd, ymax = label_sd + sd), width = 0.2)
}

# Adjust text angle on the X-axis if there are more than 3 groups
if (length(unique(sample_data$Group)) > 3) {
  alluvial_plot <- alluvial_plot + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
}

# Get rank names from the phyloseq object
phyloseq::rank_names(phyloseq_object)

# Customize the bar plot with a manual color scale and theme
bar_plot_1 <- bar_plot + 
  scale_fill_manual(values = color_set) +
  scale_x_discrete(limits = axis_order) +
  custom_theme
bar_plot_1

# Customize the alluvial plot with a manual color scale and theme
bar_plot_2 <- alluvial_plot + 
  scale_fill_manual(values = color_set) +
  scale_x_discrete(limits = axis_order) + 
  custom_theme
bar_plot_2

# Combine the bar plot and alluvial plot side by side using cowplot
combined_plot <- cowplot::plot_grid(bar_plot_1, bar_plot_2, labels = c("A", "B"))

# Add a title to the combined plot
combined_plot <- cowplot::ggdraw() +
  cowplot::draw_plot(combined_plot, 0, 0, 1, 0.9) +  # Adjust plot position and size
  cowplot::draw_label("Phylum Relative Abundance According to Mtb Infection Status", 
                      x = 0.5, y = 0.95, hjust = 0.5, size = 16)

# Print the combined plot with title
print(combined_plot)


# Save the combined plot as a high-resolution JPG file
ggsave("Results/Figure 6A.jpg", plot = combined_plot, width = 12, height = 6, dpi = 600)  
```
## **Genus**
```{r, warning=FALSE, message=FALSE}
# Assign the phyloseq object to a variable
phyloseq_object <- MtbInfectionStatus_phyloseq 
group_col <- "Group"  # Define the group column name
rank <- "Genus"  # Define the taxonomic rank
add_labels <- TRUE  # Flag to add labels
show_sd <- FALSE  # Flag to show standard deviation
top_n <- 10  # Number of top taxa to include
transform_abundance <- TRUE  # Flag to transform data to relative abundance

# Get unique levels for group column
axis_order <- phyloseq::sample_data(phyloseq_object)$Group %>% unique()

# Perform taxonomic glomming (grouping)
phyloseq_data <- ggClusterNet::tax_glom_wt(ps = phyloseq_object, ranks = rank)
  
# Transform to relative abundance if specified
if (transform_abundance == TRUE) {
  phyloseq_data <- phyloseq_data %>%
    phyloseq::transform_sample_counts(function(x) {x / sum(x)})
}
  
# Extract OTU and taxonomy tables
otu_table <- phyloseq::otu_table(phyloseq_data)
tax_table <- phyloseq::tax_table(phyloseq_data)
  
# Adjust taxonomy table to group non-top taxa as "others"
for (i in 1:dim(tax_table)[1]) {
  if (row.names(tax_table)[i] %in% names(sort(rowSums(otu_table), decreasing = TRUE)[1:top_n])) {
    tax_table[i, rank] <- tax_table[i, rank]
  } else {
    tax_table[i, rank] <- "others"
  }
}
# Update the phyloseq object with the modified taxonomy table
phyloseq::tax_table(phyloseq_data) <- tax_table
  
# Melt the phyloseq object to a data frame
taxonomies <- phyloseq_data %>%
  phyloseq::psmelt()

# Convert abundance to percentage
taxonomies$Abundance <- taxonomies$Abundance * 100
# Rename taxonomy column to "taxonomy"
colnames(taxonomies) <- gsub(rank, "taxonomy", colnames(taxonomies))

# Initialize an empty data frame
final_data <- c()
# Loop over each group to calculate relative abundance
for (i in 1:length(unique(phyloseq::sample_data(phyloseq_object)$Group))) {
  group_name <- as.data.frame(table(phyloseq::sample_data(phyloseq_object)$Group))[i, 1]
  group_size <- as.data.frame(table(phyloseq::sample_data(phyloseq_object)$Group))[i, 2]

  # Filter data by group
  group_data <- taxonomies %>% 
    dplyr::filter(Group == group_name)
  group_data$Abundance <- group_data$Abundance / group_size
  
  # Create a temporary data frame for the current group
  temp_data <- data.frame(Sample = group_data$Sample, 
                          Abundance = group_data$Abundance, 
                          taxonomy = group_data$taxonomy, 
                          Group = group_data$Group)

  # Combine data for all groups
  if (i == 1) {
    final_data <- temp_data
  } else {
    final_data <- rbind(final_data, temp_data)
  }
}

# Update taxonomies data frame with combined data
taxonomies <- final_data

# Group data by taxonomy and group columns
grouped_taxa <- dplyr::group_by(taxonomies, taxonomy, Group)
# Summarize abundance and standard deviation by group and taxonomy
summarized_data <- dplyr::summarize(grouped_taxa, sum(Abundance), sd(Abundance))

# Group data by taxonomy to calculate total abundance
taxonomy_groups <- dplyr::group_by(taxonomies, taxonomy)
total_abundance <- dplyr::summarize(taxonomy_groups, sum(Abundance))
head(total_abundance)
# Rename columns for total abundance data
colnames(total_abundance) <- c("taxonomy", "total_sum")
# Arrange taxa by total abundance in descending order
total_abundance <- dplyr::arrange(total_abundance, desc(total_sum))
  
# Preview the summarized data
head(summarized_data)
# Rename columns in summarized data
colnames(summarized_data) <- c("taxonomy", "group", "Abundance", "sd")
# Convert taxonomy to a factor and order by total abundance
summarized_data$taxonomy <- factor(summarized_data$taxonomy, order = TRUE, levels = total_abundance$taxonomy)

# Copy summarized data for further processing
summarized_data_2 <- summarized_data

# Calculate cumulative sums for plotting labels
plot_data <- plyr::ddply(summarized_data_2, "group", summarize, label_sd = cumsum(Abundance), label_y = cumsum(Abundance) - 0.5 * Abundance)
head(plot_data)
  
# Combine summarized data with cumulative sum labels
plot_data <- cbind(as.data.frame(summarized_data_2), as.data.frame(plot_data)[, -1])

# Set label column to be the taxonomy
plot_data$label <- plot_data$taxonomy

# Order taxonomy levels by total abundance
plot_data$taxonomy <- factor(plot_data$taxonomy, order = TRUE, levels = c(as.character(total_abundance$taxonomy)))

# Create a bar plot for relative abundance
bar_plot <- ggplot(plot_data, aes(x = group, y = Abundance, fill = taxonomy, order = taxonomy)) +
  geom_bar(stat = "identity", width = 0.5, color = "black") +
  theme(axis.title.x = element_blank()) +
  theme(legend.text = element_text(size = 6)) +
  scale_y_continuous(name = "Relative abundance (%)") +
  guides(fill = guide_legend(title = rank)) +
  labs(x = "", y = "Relative abundance (%)", title = "")

# Adjust X-axis to follow the order of groups
bar_plot <- bar_plot + scale_x_discrete(limits = axis_order)

# Add error bars if the show_sd flag is TRUE
if (show_sd == TRUE) {
  bar_plot <- bar_plot +
    geom_errorbar(aes(ymin = label_sd - sd, ymax = label_sd + sd), width = 0.2)
}

# Convert sample data to a data frame
sample_data <- as.data.frame(phyloseq::sample_data(phyloseq_object))
# Adjust text angle on the X-axis if there are more than 3 groups
if (length(unique(sample_data$Group)) > 3) {
  bar_plot <- bar_plot + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
}

# Get the taxonomy levels
taxa <- plot_data$taxonomy
# Calculate the number of factor levels
num_factors <- taxa %>% levels() %>% length()

# Summarize the number of occurrences of each factor level
factor_summary <- taxa %>%
  as.factor() %>%
  summary() %>%
  as.data.frame()

# Add row names as an ID column
factor_summary$id <- row.names(factor_summary)

# Arrange factors by ID and data by taxonomy
arranged_factors <- dplyr::arrange(factor_summary, id)
arranged_plot_data <- dplyr::arrange(plot_data, taxonomy)
head(arranged_plot_data)
# Assign an ID to each row in the arranged plot data
arranged_plot_data$ID <- factor(rep(c(1:num_factors), factor_summary$.))

head(arranged_plot_data)
arranged_plot_data$Abundance

# Create an alluvial plot for relative abundance
alluvial_plot <- ggplot(arranged_plot_data, aes(x = group, y = Abundance, fill = taxonomy, alluvium = taxonomy, stratum = ID)) +
  ggalluvial::geom_flow(aes(fill = taxonomy, colour = taxonomy),
            stat = "alluvium", lode.guidance = "rightleft",
            color = "black", size = 0.2, width = 0.35, alpha = .2)  +
  geom_bar(width = 0.45, stat = "identity") +
  labs(x = "", y = "Relative abundance (%)", title = "") +
  guides(fill = guide_legend(title = rank), color = FALSE) +
  scale_y_continuous(expand = c(0, 0))

# Add error bars to the alluvial plot if the show_sd flag is TRUE
if (show_sd == TRUE) {
  alluvial_plot <- alluvial_plot +
    geom_errorbar(aes(ymin = label_sd - sd, ymax = label_sd + sd), width = 0.2)
}

# Adjust text angle on the X-axis if there are more than 3 groups
if (length(unique(sample_data$Group)) > 3) {
  alluvial_plot <- alluvial_plot + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
}

# Get rank names from the phyloseq object
phyloseq::rank_names(phyloseq_object)

# Customize the bar plot with a manual color scale and theme
bar_plot_1 <- bar_plot + 
  scale_fill_manual(values = color_set) +
  scale_x_discrete(limits = axis_order) +
  custom_theme
bar_plot_1

# Customize the alluvial plot with a manual color scale and theme
bar_plot_2 <- alluvial_plot + 
  scale_fill_manual(values = color_set) +
  scale_x_discrete(limits = axis_order) + 
  custom_theme
bar_plot_2

# Combine the bar plot and alluvial plot side by side using cowplot
combined_plot <- cowplot::plot_grid(bar_plot_1, bar_plot_2, labels = c("A", "B"))

# Add a title to the combined plot
combined_plot <- cowplot::ggdraw() +
  cowplot::draw_plot(combined_plot, 0, 0, 1, 0.9) +  # Adjust plot position and size
  cowplot::draw_label("Genus Relative Abundance According to Mtb Infection Status", 
                      x = 0.5, y = 0.95, hjust = 0.5, size = 16)

# Print the combined plot with title
print(combined_plot)


# Save the combined plot as a high-resolution JPG file
ggsave("Results/Figure 6B.jpg", plot = combined_plot, width = 12, height = 6, dpi = 600)  
```

# **Differential abundance**
```{r, warning=FALSE, message=FALSE}
# Load phyloseq object and process taxonomy
physeq_data <- MtbInfectionStatus_phyloseq
# Analysis parameters
analysis_group <- "Group"  # Group variable for analysis
p_value_threshold <- 0.05  # Threshold for p-value significance
log_fold_change_threshold <- 0  # Threshold for log fold change
artificial_groups <- NULL  # Placeholder for artificial group comparisons
normalization_method <- "TMM"  # Method for normalization
rank_selection <- 6  # Taxonomic rank for analysis
contrast_matrix <- NULL  # Placeholder for contrast matrix

# Initialize a list to store plots
plot_list <- list()  # List to store individual plots

# Prepare phyloseq data based on rank selection
if (rank_selection %in% c("OTU", "gene", "meta")) {
    physeq_data <- physeq_data  # No change needed
} else if (rank_selection %in% c(1:7)) {
    physeq_data <- physeq_data %>% 
        ggClusterNet::tax_glom_wt(ranks = rank_selection)  # Aggregate taxa at specified rank
} else if (rank_selection %in% c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")) {
    # No action needed for standard taxonomic ranks
} else {
    print("Unknown rank_selection, please check")  # Print error if rank selection is invalid
}

# Prepare design matrix and count data
sample_data <- as.data.frame(phyloseq::sample_data(physeq_data))  # Convert sample data to dataframe
descriptive_groups <- as.character(levels(as.factor(sample_data$Group)))  # Extract group levels

if (is.null(artificial_groups)) {
    contrast_combinations <- combn(descriptive_groups, 2)  # Generate all pairwise contrasts
} else if (!is.null(artificial_groups)) {
    contrast_combinations <- as.matrix(contrast_matrix)  # Use provided contrast matrix
}

otu_table_data <- as.data.frame(ggClusterNet::vegan_otu(physeq_data))  # Extract OTU table
count_matrix <- as.matrix(otu_table_data)  # Convert to matrix and transpose
count_matrix <- t(count_matrix)
sample_data$SampleType <- as.factor(sample_data$Group)  # Convert Group to factor
dge_list <- edgeR::DGEList(counts = count_matrix, group = sample_data$SampleType)  # Create DGEList object
dge_list <- edgeR::calcNormFactors(dge_list, method = normalization_method)  # Normalize counts

# Define design matrix for GLM
design_matrix <- model.matrix(~ 0 + dge_list$samples$group)  # Create design matrix without intercept
colnames(design_matrix) <- levels(sample_data$SampleType)  # Set column names
dge_list <- edgeR::estimateGLMCommonDisp(dge_list, design_matrix)  # Estimate common dispersion
dge_list <- edgeR::estimateGLMTagwiseDisp(dge_list, design_matrix)  # Estimate tagwise dispersion
glm_fit <- edgeR::glmFit(dge_list, design_matrix)  # Fit GLM

# Perform differential analysis and plot results
for (i in 1:dim(contrast_combinations)[2]) {
    comparison_groups <- contrast_combinations[, i]  # Extract current comparison groups
    print(comparison_groups)  # Print comparison groups

    contrast_name <- paste(comparison_groups[1], comparison_groups[2], sep = "-")  # Create contrast name
    contrast_matrix <- limma::makeContrasts(contrasts = contrast_name, levels = c(as.character(levels(as.factor(sample_data$Group))))) 
    glm_lrt <- edgeR::glmLRT(glm_fit, contrast = contrast_matrix)  # Perform likelihood ratio test

    diff_test_result <- edgeR::decideTestsDGE(glm_lrt, adjust.method = "fdr", p.value = p_value_threshold, lfc = log_fold_change_threshold)  # Adjust p-values and decide tests
    summary(diff_test_result)  # Summarize differential test results
    result_table <- glm_lrt$table  # Extract results table
    result_table$sig <- diff_test_result  # Add significance results
    row.names(count_matrix)[1:6]  # Print row names for checking

    result_table <- cbind(result_table, padj =result_table$PValue)  # Adjust p-values
    enriched_taxa <- row.names(subset(result_table, sig == 1))  # Identify enriched taxa
    depleted_taxa <- row.names(subset(result_table, sig == -1))  # Identify depleted taxa

   
    result_table$level <- as.factor(ifelse(as.vector(result_table$sig) == 1, "enriched", 
                                       ifelse(as.vector(result_table$sig) == -1, "depleted", 
                                              ifelse(result_table$padj < 0.05, "unplot", "nosig"))))
    result_table <- data.frame(row.names = row.names(result_table), logFC = result_table$logFC, level = result_table$level, p = result_table$PValue)  # Prepare result table

    filtered_table <- result_table %>%
        dplyr::filter(level %in% c("enriched", "depleted", "nosig"))  # Filter based on significance

    filtered_table$Genus <- row.names(filtered_table)  # Add Genus names
    if (nrow(filtered_table) <= 1) {
        next  # Skip if no significant results
    }
    
    top_taxa <- filtered_table %>% 
        dplyr::mutate(ord = logFC^2) %>%
        dplyr::filter(level != "nosig") %>%
        dplyr::arrange(desc(ord)) %>%
        head(n = 5)  # Select top 5 taxa

    # Store the top 5 enriched/depleted results in the list
    plot_list[[i]] <- ggplot(filtered_table, aes(x = logFC, y = -log2(p), color = level)) +
    geom_point(size = 3.5, alpha = 0.7, shape = 16) +  # Slightly larger point size with transparency
    geom_hline(yintercept = -log2(p_value_threshold), linetype = "dashed", color = 'black', size = 0.9) +  # Thicker dashed line for p-value threshold
    geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = 'black', size = 0.9) +  # Thicker dashed lines for logFC thresholds
    ggrepel::geom_text_repel(data = top_taxa, aes(x = logFC, y = -log2(p), label = Genus), 
                             size = 4, box.padding = 0.5, max.overlaps = Inf, 
                             segment.color = 'grey50', segment.size = 0.6, 
                             nudge_x = 0.2, nudge_y = 0.2) +  # Adjusted padding and overlap handling
    scale_color_manual(values = c("enriched" = "red", "depleted" = "blue", "nosig" = "grey")) +  # Colorblind-friendly palette
    labs(title = contrast_name, x = "Log Fold Change", y = "-Log2 P-Value", color = "Significance") +  # Add legend title
    theme_minimal(base_size = 14) +  # Use a minimal theme for a cleaner look
    theme(
        plot.title = element_text(size = 18, face = "bold", hjust = 0.5),  # Center and bold title
        axis.title = element_text(size = 15),  # Larger axis titles
        axis.text = element_text(size = 12),  # Larger axis text
        legend.position = "top",  # Place legend at the top for better visibility
        legend.title = element_text(size = 12),  # Larger legend title
        legend.text = element_text(size = 10),  # Larger legend text
        panel.grid.major = element_line(size = 0.5, linetype = 'solid', color = "grey90"),  # Lighter grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines for a cleaner look
        panel.border = element_rect(color = "grey80", fill = NA, size = 0.5)  # Add border around the plot
    )


    colnames(result_table) <- paste(contrast_name, colnames(result_table), sep = "")  # Rename columns with contrast name

    if (i == 1) {
        combined_results <- result_table  # Initialize combined results
    } else {
        combined_results <- cbind(combined_results, result_table)  # Combine results
    }
}

# Print all plots
print(plot_list)  # Print all plots stored in the list

# Combine and save the plots
combined_plot <- wrap_plots(plot_list, ncol = 3)
ggsave(filename = "Results/Figure 7.jpg", plot = combined_plot, width = 15, height = 10, dpi = 600)

```
# **Biomarker Identification**
## **LEfSe analysis**
```{r, warning=FALSE, message=FALSE}
# Load the saved phyloseq object from an RDS file
ps <- MtbInfectionStatus_phyloseq
mytheme1 <- ggplot2::theme_bw() + 
  ggplot2::theme(
    panel.background = ggplot2::element_blank(),  # Remove background color
    panel.grid = ggplot2::element_blank(),  # Remove grid lines
    legend.position = "right",  # Position legend on the right
    legend.title = ggplot2::element_blank(),  # Remove legend title
    legend.background = ggplot2::element_blank(),  # Remove legend background
    legend.key = ggplot2::element_blank(),  # Remove legend key background
    plot.title = ggplot2::element_text(hjust = 0.5),  # Center plot title without vertical adjustment
    axis.title.y = ggplot2::element_text(colour = "black"),  # Set Y axis title color
    axis.text = ggplot2::element_text()  # Set axis text style
  )

# Function to generate a base plot from phyloseq data
# Function to create a circular phylogenetic tree plot with a well-edited title
p_base = function(ps, Top = 100, ranks = 6, title = "Circular Phylogenetic Tree") {
  alltax = ps %>%
    ggClusterNet::tax_glom_wt(ranks = ranks) %>%   # Collapse taxa at a given rank
    ggClusterNet::filter_OTU_ps(Top) %>%           # Filter top OTUs
    ggClusterNet::vegan_tax() %>%                  # Extract taxonomy table
    as.data.frame()                                # Convert to data frame
  
  alltax$OTU = row.names(alltax)                   # Add OTU IDs as a column
  
  # Concatenate taxonomic ranks into a single string, separated by "_Rank_"
  alltax$Kingdom = paste(alltax$Kingdom, sep = "_Rank_")
  for (i in 2:ranks) {
    alltax[, i] = paste(alltax[, i - 1], alltax[, i], sep = "_Rank_")
  }
  
  alltax[is.na(alltax)] = "Unknown"               # Replace NA values with "Unknown"
  trda <- MicrobiotaProcess::convert_to_treedata(alltax)  # Convert to tree data format
  
  # Create a circular phylogenetic tree plot
  p <- ggtree(trda, layout = "circular", size = 0.2, xlim = c(30, NA)) +
    geom_point(
      pch = 21,                                   # Set point shape
      size = 3,                                   # Set point size
      alpha = 1,                                  # Set point transparency
      fill = "#FFFFB3"                            # Set fill color for points
    ) +
    ggtitle(title) +                             # Add title with the given argument
    theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5),  # Title appearance
          axis.text = element_blank(),          # Hide axis text
          axis.title = element_blank(),         # Hide axis titles
          panel.background = element_blank(),   # Remove background grid
          panel.grid = element_blank(),         # Remove panel grid
          legend.position = "none")              # Remove legend
  
  # Extract the label for each node, using the last taxonomic rank in the string
  p$data$lab2 <- p$data$label %>% strsplit("_Rank_") %>%
    sapply(function(x) x[length(x)])
  
  # Clean up the labels
  p$data$lab2 = gsub("st__", "", p$data$lab2)
  p$data$nodeSize = 1                              # Set node size for all nodes
  
  return(p)                                        # Return the ggplot object
}


# Function to perform LDA (Linear Discriminant Analysis) on the phyloseq object
LDA_Micro = function(ps = ps,
                     Top = 100,
                     ranks = 6,
                     p.lvl = 0.05,
                     lda.lvl = 2,
                     seed = 11,
                     adjust.p = F) {

  # Process taxonomy data similarly to p_base function
  alltax = ps %>%
    ggClusterNet::tax_glom_wt(ranks = ranks) %>%
    phyloseq::filter_taxa(function(x) sum(x) > 0, TRUE) %>%
    ggClusterNet::filter_OTU_ps(Top) %>%
    ggClusterNet::vegan_tax() %>%
    as.data.frame()
  alltax$OTU = row.names(alltax)
  
  # Concatenate taxonomic ranks similarly as in p_base
  alltax$Kingdom = paste(alltax$Kingdom, sep = "_Rank_")
  for (i in 2:ranks) {
    alltax[, i] = paste(alltax[, i - 1], alltax[, i], sep = "_Rank_")
  }
  
  # Prepare OTU table for LDA analysis
  otu = ps %>%
    ggClusterNet::tax_glom_wt(ranks = ranks) %>%
    phyloseq::filter_taxa(function(x) sum(x) > 0, TRUE) %>%
    ggClusterNet::filter_OTU_ps(Top) %>%
    ggClusterNet::vegan_otu() %>%
    t() %>%
    as.data.frame()
  
  # Merge OTU data with taxonomy data
  otu_tax = merge(otu, alltax, by = "row.names", all = F)
  
  # Summarize OTU counts at each taxonomic level
  tem = colnames(alltax)[-length(colnames(alltax))]
  i = 1
  tem2 = c("k__", "p__", "c__", "o__", "f__", "g__", "s__", "st__")
  for (i in 1:ranks) {
    rank1 <- otu_tax %>%
      dplyr::group_by(!!sym(tem[i])) %>%
      dplyr::summarise_if(is.numeric, sum, na.rm = TRUE)
    colnames(rank1)[1] = "id"
    rank1$id = paste(tem2[i], rank1$id, sep = "")
    if (i == 1) {
      all = rank1
    }
    if (i != 1) {
      all = rbind(all, rank1)
    }
  }
  
  # Convert summarized data to phyloseq object for further analysis
  data1 = as.data.frame(all)
  row.names(data1) = data1$id
  data1$id = NULL
  
  ps_G_graphlan = phyloseq::phyloseq(
    phyloseq::otu_table(as.matrix(data1), taxa_are_rows = TRUE),
    phyloseq::sample_data(ps)
  )
  
  # Extract OTU and sample data for LDA
  otu = as.data.frame((ggClusterNet::vegan_otu(ps_G_graphlan)))
  map = as.data.frame(phyloseq::sample_data(ps_G_graphlan))
  claslbl = map$Group %>% as.factor()
  
  set.seed(seed)  # Set seed for reproducibility
  
  # Perform Kruskal-Wallis rank sum test on OTUs
  rawpvalues <- apply(otu, 2, function(x) kruskal.test(x, claslbl)$p.value)
  ord.inx <- order(rawpvalues)
  rawpvalues <- rawpvalues[ord.inx]
  
  # Adjust p-values if specified
  clapvalues <- p.adjust(rawpvalues, method = "fdr")
  
  # Prepare data for LDA
  wil_datadf <- as.data.frame(otu[, ord.inx])
  
  # Perform LDA and calculate LDAscore
  ldares <- MASS::lda(claslbl ~ ., data = wil_datadf)
  ldamean <- as.data.frame(t(ldares$means))
  class_no <<- length(unique(claslbl))
  ldamean$max <- apply(ldamean[, 1:class_no], 1, max)
  ldamean$min <- apply(ldamean[, 1:class_no], 1, min)
  ldamean$LDAscore <- signif(log10(1 + abs(ldamean$max - ldamean$min) / 2), digits = 3)
  
  # Determine the class with the highest LDAscore
  a = rep("A", length(ldamean$max))
  for (i in 1:length(ldamean$max)) {
    name = colnames(ldamean[, 1:class_no])
    a[i] = name[ldamean[, 1:class_no][i, ] %in% ldamean$max[i]]
  }
  ldamean$class = a
  
  # Add p-values and FDR to the results table
  tem1 = row.names(ldamean)
  ldamean$Pvalues <- signif(rawpvalues[match(row.names(ldamean), names(rawpvalues))], digits = 5)
  ldamean$FDR <- signif(clapvalues, digits = 5)
  resTable <- ldamean
  rawNms <- rownames(resTable)
  rownames(resTable) <- gsub("`", '', rawNms)
  
  # Count significant features based on criteria
  if (adjust.p) {
    de.Num <- sum(clapvalues <= p.lvl & ldamean$LDAscore >= lda.lvl)
  } else {
    de.Num <- sum(rawpvalues <= p.lvl & ldamean$LDAscore >= lda.lvl)
  }
  
  # Display the results message
  if (de.Num == 0) {
    current.msg <<- "No significant features were identified with given criteria."
  } else {
    current.msg <<- paste("A total of", de.Num, "significant features with given criteria.")
  }
  print(current.msg)
  
  # Sort the results table by p-values and LDAscore
  ord.inx <- order(resTable$Pvalues, resTable$LDAscore)
  resTable <- resTable[ord.inx, , drop = FALSE]
  resTable <- resTable[, c(ncol(resTable), 1:(ncol(resTable) - 1))]
  
  # Filter the significant taxa
  if (adjust.p) {
    taxtree = resTable[clapvalues <= p.lvl & ldamean$LDAscore >= lda.lvl, ]
  } else {
    taxtree = resTable[ldamean$Pvalues <= p.lvl, ]
  }
  
  # Assign colors to significant taxa based on their class
  colour = c('darkgreen', 'red', "blue", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF")
  selececol = colour[1:length(levels(as.factor(taxtree$class)))]
  names(selececol) = levels(as.factor(taxtree$class))
  A = rep("a", length(row.names(taxtree)))
  for (i in 1:length(row.names(taxtree))) {
    A[i] = selececol[taxtree$class[i]]
  }
  
  taxtree$color = A  # Assign color to taxtree
  
  # Prepare the final output as a list
  lefse_lists = data.frame(node = row.names(taxtree),
                           color = A,
                           Group = taxtree$class,
                           stringsAsFactors = FALSE)
  
  return(list(lefse_lists, taxtree))
}

# Function to annotate clades in the phylogenetic tree
clade.anno_wt <- function(gtree, anno.data, alpha = 0.2, anno.depth = 5, anno.x = 10, 
                          anno.y = 40) {
  
  short.labs <- c(letters, paste(letters, 1:500, sep = ""))
  
  # Helper function to calculate offset for clade labels
  get_offset <- function(x) {
    (x * 0.2 + 0.2)^2
  }
  
  # Helper function to calculate the angle for clade labels
  get_angle <- function(node) {
    data <- gtree$data
    sp <- tidytree::offspring(data, node)$node
    sp2 <- c(sp, node)
    sp.df <- data[match(sp2, data$node), ]
    mean(range(sp.df$angle))
  }
  
  # Arrange annotation data and assign colors to clades
  anno.data <- dplyr::arrange(anno.data, node)
  hilight.color <- anno.data$color
  node_list <- anno.data$node
  node_ids <- (gtree$data %>% filter(label %in% node_list) %>% 
                 arrange(label))$node
  anno <- rep("yellow", nrow(gtree$data))
  
  # Highlight clades with specified colors
  for (i in 1:length(node_ids)) {
    n <- node_ids[i]
    color <- hilight.color[i]
    anno[n] <- color
    mapping <- gtree$data %>% filter(node == n)
    nodeClass <- as.numeric(mapping$nodeDepth)
    offset <- get_offset(nodeClass)
    gtree <- gtree + geom_hilight(node = n, fill = color, 
                                  alpha = alpha, extend = offset)
  }
  
 # Annotate clades with labels
  short.labs.anno <- NULL
  for (i in 1:length(node_ids)) {
    n <- node_ids[i]
    mapping <- gtree$data %>% filter(node == n)
    nodeClass <- as.numeric(mapping$nodeDepth)
    if (nodeClass <= anno.depth) {
      lab <- short.labs[1]
      short.labs <- short.labs[-1]
      if (is.null(short.labs.anno)) {
        short.labs.anno = data.frame(lab = lab, annot = mapping$lab2, 
                                     stringsAsFactors = F)
      } else {
        short.labs.anno = rbind(short.labs.anno, c(lab, mapping$lab2))
      }
    } else {
      lab <- mapping$lab2
    }
    
    offset <- get_offset(nodeClass) - 0.4
    angle <- get_angle(n) + 90
    gtree <- gtree + geom_cladelabel(node = n, label = lab, 
                                     angle = angle, fontsize = 1 + sqrt(nodeClass), 
                                     offset = offset, barsize = NA, hjust = 0.5)
  }
  
  # Generate legend for clade colors
  if (!is.null(short.labs.anno)) {
    anno_shapes = sapply(short.labs.anno$lab, utf8ToInt)
    stable.p <- ggpubr::ggtexttable(short.labs.anno, rows = NULL, 
                                    theme = ggpubr::ttheme(
                                      colnames.style = ggpubr::colnames_style(fill = "white"),
                                      tbody.style = ggpubr::tbody_style(fill = ggpubr::get_palette("RdBu", 6))
                                    ))
  }
  
  y = (1:length(unique(anno.data$Group)))
  
 pleg <- ggplot() + geom_point2(aes(
    y = y,
    x = rep(1, length(unique(anno.data$color))), fill = as.factor(1:length(unique(anno.data$Group)))
  ), pch = 21, size = 2) +
    geom_text(aes(y = y,
                  x = rep(1, length(unique(anno.data$color))), label = unique(anno.data$Group)),
              hjust = -0.2
    ) + scale_fill_manual(values = unique(anno.data$color), guide = F) +
    theme_void()


  layout <- "
  AAAAAABB
  AAAAAABB
  AAAAAABB
  CCCCCCCC
  "
  
  # Combine tree plot and legend layout
  if (is.null(short.labs.anno)) {
    gtree <- gtree + pleg + plot_layout(design = layout)
  } else {
    gtree <- gtree + stable.p + pleg + plot_layout(design = layout)
  }
  
}


# Function to create a bar plot for LEfSe results, highlighting taxa with significant LDA scores
lefse_bar = function(taxtree = tablda[[2]]) {
  taxtree = tablda[[2]]
  taxtree$ID = row.names(taxtree)
  
  # Prepare LEfSe data for bar plot
  taxtree$ID = gsub("_Rank_", ";", taxtree$ID)
  taxtree <- taxtree %>%
    arrange(class, LDAscore)
  taxtree$ID = factor(taxtree$ID, levels = taxtree$ID)
  taxtree$class = factor(taxtree$class, levels = unique(taxtree$class))
  
  # Create the bar plot with a customized title
  pbar <- ggplot(taxtree) + 
  geom_bar(aes(y = ID, x = LDAscore, fill = class), stat = "identity") +
  scale_fill_manual(values = unique(taxtree$color)) +
  mytheme1 +
  scale_x_continuous(limits = c(0, max(taxtree$LDAscore) * 1.2)) +
  labs(title = "LDA scores of significant taxa",  # Add title
       x = "LDA Score", # x-axis label
       y = "Taxa") +    # y-axis label
  theme(plot.title = element_text(size = 14, face = "bold", hjust = 0.5), # Adjust title size
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
  return(pbar)
}


# Initialize empty lists to store the plots and results
tree_plots <- list()
bar_plots <- list()
tree_lefse_data <- list()

# Loop through different taxonomic ranks and generate plots/results
for (j in 2:6) {
  
  # Generate base tree plot for the given rank
  p1 <- p_base(ps, Top = 200, ranks = j,title = paste("Circular Tree Plot"))
  
  # Perform LDA analysis and get the results
  tablda <- LDA_Micro(ps = ps,
                      Top = 200,
                      ranks = j,
                      p.lvl = 0.05,
                      lda.lvl = 2,
                      seed = 11,
                      adjust.p = F)
  
  # Annotate clades in the tree plot
  p2 <- clade.anno_wt(p1, tablda[[1]], alpha = 0.3, anno.depth = 2)
  tree_plots[[paste0("Rank_", j, "_tree_plot")]] <- p2  # Save tree plot in the list
  
  # Create a bar plot of LEfSe results
  p <- lefse_bar(taxtree = tablda[[2]])
  bar_plots[[paste0("Rank_", j, "_bar_plot")]] <- p  # Save bar plot in the list
  
  # Save LEfSe data for the current rank
  res <- tablda[[2]]
  tree_lefse_data[[paste0("Rank_", j, "_tree_lefse_data")]] <- res  # Save data in the list
}

# Access the plots and data for rank 2
tree_plots[["Rank_2_tree_plot"]]
bar_plots[["Rank_2_bar_plot"]]
tree_lefse_data[["Rank_2_tree_lefse_data"]]

# Save the Rank 2 tree plot as a high-resolution image
ggsave(filename = "Results/Figure 8A.jpg", 
       plot = tree_plots[["Rank_2_tree_plot"]], 
       width = 10, height = 8, dpi = 600)

# Save the Rank 2 bar plot as a high-resolution image
ggsave(filename = "Results/Figure 8B.jpg", 
       plot = bar_plots[["Rank_2_bar_plot"]], 
       width = 10, height = 8, dpi = 600)


```
# **Machine Learning**
## **Compare machine learning models**
```{r, warning=FALSE, message=FALSE, error=TRUE}
MicroRoc <- function(otu = NULL, tax = NULL, map = NULL, tree = NULL,
                     ps = NULL, group_var = NULL, repnum = 5) {
  
  # Prepare the phyloseq object for analysis
  ps <- ggClusterNet::inputMicro(otu, tax, map, tree, ps, group = group_var)
  
  # Extract sample data and OTU table from the phyloseq object
  sample_mapping <- as.data.frame(phyloseq::sample_data(ps))
  
# Ensure the group_var is treated as a factor with explicit levels
sample_mapping[[group_var]] <- factor(sample_mapping[[group_var]])

# Convert the factor levels to numeric: 0 for the first level, 1 for the second
sample_mapping[[group_var]] <- as.numeric(sample_mapping[[group_var]]) - 1

# Check the conversion
 table(sample_mapping[[group_var]])  # Should show counts of 0s and 1s

  otu_table <- as.data.frame(t(ggClusterNet::vegan_otu(ps)))
  colnames(otu_table) <- gsub("-", "_", colnames(otu_table)) 
  
  # Prepare the data for modeling
  data_for_modeling <- as.data.frame(t(otu_table))
  data_for_modeling$group <- factor(sample_mapping[[group_var]])  # Ensure group is a factor
  colnames(data_for_modeling) <- paste(colnames(data_for_modeling), sep = "")
  
  # Random Forest, SVM, and GLM models
  models <- c("RF", "SVM", "GLM")
  auc_scores <- list()
  roc_data <- list()
  set.seed(100)  # Use the same seed value for reproducibility

  for (model in models) {
    auc_values <- numeric(repnum)  # Store AUC for each fold
    tpr_fpr_list <- list()  # Store TPR and FPR for each fold
    
    folds <- createFolds(y = data_for_modeling$group, k = repnum)
    
    for (i in 1:repnum) {
      test_fold <- data_for_modeling[folds[[i]], ]
      train_fold <- data_for_modeling[-folds[[i]], ]
      
      if (model == "RF") {
        rf_model <- randomForest(group ~ ., data = train_fold, importance = TRUE)
        rf_predictions <- predict(rf_model, newdata = test_fold, type = "prob")[, 2]

        roc_result <- roc(test_fold$group, rf_predictions)
        auc_values[i] <- auc(roc_result)
        tpr_fpr_list[[i]] <- data.frame(tpr = roc_result$sensitivities, fpr = 1 - roc_result$specificities)
        
      } else if (model == "SVM") {
        svm_model <- svm(group ~ ., data = train_fold, probability = TRUE)
        svm_predictions <- attr(predict(svm_model, test_fold, probability = TRUE), "probabilities")[, 2]

        roc_result <- roc(test_fold$group, svm_predictions)
        auc_values[i] <- auc(roc_result)
        tpr_fpr_list[[i]] <- data.frame(tpr = roc_result$sensitivities, fpr = 1 - roc_result$specificities)
        
      } else if (model == "GLM") {
        glm_model <- glm(group ~ ., family = binomial, data = train_fold)
        glm_predictions <- predict(glm_model, test_fold, type = "response")

        roc_result <- roc(test_fold$group, glm_predictions)
        auc_values[i] <- auc(roc_result)
        tpr_fpr_list[[i]] <- data.frame(tpr = roc_result$sensitivities, fpr = 1 - roc_result$specificities)
      }
    }
    
    # Calculate mean AUC and 95% CI for the model
    mean_auc <- mean(auc_values)
    auc_ci <- quantile(auc_values, probs = c(0.025, 0.975))  # 95% CI using quantiles
    
    # Combine TPR/FPR data across folds and calculate mean TPR at each FPR
    combined_roc_data <- bind_rows(tpr_fpr_list)
    mean_roc <- combined_roc_data %>%
      group_by(fpr) %>%
      summarise(mean_tpr = mean(tpr, na.rm = TRUE), 
                lower_ci = quantile(tpr, 0.025, na.rm = TRUE),
                upper_ci = quantile(tpr, 0.975, na.rm = TRUE))
    
    # Store AUC results and ROC curve data
    auc_scores[[model]] <- list(mean = mean_auc, ci = auc_ci)
    roc_data[[model]] <- mean_roc
  }
  
# Function to create individual ROC plots with CI 
plot_roc <- function(roc_data, auc, model_name, color) {
  ggplot(roc_data, aes(x = fpr)) +
    # Shaded region representing the 95% confidence interval
    geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), fill = color, alpha = 0.2) +
    # Mean ROC curve line
    geom_line(aes(y = mean_tpr), color = color, size = 1) +
    # Labels and title
    labs(x = "False Positive Rate", 
         y = "True Positive Rate", 
         title = sprintf("Performance of the %s Machine Learning Model", model_name)) +
    # AUC text annotation
    annotate("text", x = 0.75, y = 0.25, label = sprintf("AUC: %.3f (95%% CI: %.3f - %.3f)", 
                                                        auc$mean, auc$ci[1], auc$ci[2]), color = color) +
    # Improved minimal theme for better aesthetics
    theme_minimal(base_size = 14) +
    # Ensure that grid lines and axis labels are clear
    theme(
      plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
      panel.grid.minor = element_blank()
    )
}
# Example of how this is used:
# Create separate plots for RF, SVM, and GLM
rf_plot <- plot_roc(roc_data$RF, auc_scores$RF, "Random Forest", "red")
svm_plot <- plot_roc(roc_data$SVM, auc_scores$SVM, "SVM", "blue")
glm_plot <- plot_roc(roc_data$GLM, auc_scores$GLM, "GLM", "black")


return(list(rf_plot = rf_plot, svm_plot = svm_plot, glm_plot = glm_plot, auc_scores = auc_scores))

}
# Example usage
result <- MicroRoc(ps = Genexpert_phyloseq, group_var = "Group")
print(result$rf_plot)
print(result$svm_plot)
print(result$glm_plot)
print(result$auc_scores)

```
```{r, warning=FALSE, message=FALSE, error=TRUE}
MicroRoc <- function(otu = NULL, tax = NULL, map = NULL, tree = NULL,
                     ps = NULL, group_var = NULL, repnum = 5) {
  
  # Prepare the phyloseq object for analysis
  ps <- ggClusterNet::inputMicro(otu, tax, map, tree, ps, group = group_var)
  
  # Extract sample data and OTU table from the phyloseq object
  sample_mapping <- as.data.frame(phyloseq::sample_data(ps))
  
  # Ensure the group_var is treated as a factor with explicit levels
  sample_mapping[[group_var]] <- factor(sample_mapping[[group_var]])
  
  # Convert the factor levels to numeric: 0 for the first level, 1 for the second
  sample_mapping[[group_var]] <- as.numeric(sample_mapping[[group_var]]) - 1
  
  # Check the conversion
  table(sample_mapping[[group_var]])  # Should show counts of 0s and 1s
  
  otu_table <- as.data.frame(t(ggClusterNet::vegan_otu(ps)))
  colnames(otu_table) <- gsub("-", "_", colnames(otu_table)) 
  
  # Prepare the data for modeling
  data_for_modeling <- as.data.frame(t(otu_table))
  data_for_modeling$group <- factor(sample_mapping[[group_var]])  # Ensure group is a factor
  
  # Models to evaluate
  models <- c("RF", "SVM", "GLM")
  auc_scores <- list()
  roc_data <- list()
  
  # Define a common FPR grid
  common_fpr <- seq(0, 1, length.out = 100)
  
  set.seed(100)  # Use the same seed value for reproducibility
  
  for (model in models) {
    auc_values <- numeric(repnum)  # Store AUC for each fold
    tpr_list <- matrix(NA, nrow = length(common_fpr), ncol = repnum)  # Store interpolated TPR values
    
    folds <- createFolds(y = data_for_modeling$group, k = repnum)
    
    for (i in 1:repnum) {
      test_fold <- data_for_modeling[folds[[i]], ]
      train_fold <- data_for_modeling[-folds[[i]], ]
      
      if (model == "RF") {
        model_fit <- randomForest(group ~ ., data = train_fold, importance = TRUE)
        predictions <- predict(model_fit, newdata = test_fold, type = "prob")[, 2]
        
      } else if (model == "SVM") {
        model_fit <- svm(group ~ ., data = train_fold, probability = TRUE)
        predictions <- attr(predict(model_fit, test_fold, probability = TRUE), "probabilities")[, 2]
        
      } else if (model == "GLM") {
        model_fit <- glm(group ~ ., family = binomial, data = train_fold)
        predictions <- predict(model_fit, test_fold, type = "response")
      }
      
      # Compute ROC and interpolate TPR at common FPR
      # Ensure test_fold$group is numeric
roc_result <- roc(as.numeric(as.character(test_fold$group)), predictions)
      interpolated_tpr <- approx(x = roc_result$specificities, 
                                 y = roc_result$sensitivities, 
                                 xout = common_fpr, 
                                 method = "linear", 
                                 ties = "ordered")$y
      tpr_list[, i] <- interpolated_tpr
      auc_values[i] <- auc(roc_result)
    }
    
    # Calculate mean and CI for TPR at each FPR
    mean_tpr <- rowMeans(tpr_list, na.rm = TRUE)
    lower_ci <- apply(tpr_list, 1, quantile, probs = 0.025, na.rm = TRUE)
    upper_ci <- apply(tpr_list, 1, quantile, probs = 0.975, na.rm = TRUE)
    
    # Store AUC results and ROC curve data
    auc_scores[[model]] <- list(mean = mean(auc_values), ci = quantile(auc_values, c(0.025, 0.975)))
    roc_data[[model]] <- data.frame(fpr = common_fpr, mean_tpr = mean_tpr, lower_ci = lower_ci, upper_ci = upper_ci)
  }
  
  # Function to create individual ROC plots with CI 
  plot_roc <- function(roc_data, auc, model_name, color) {
    ggplot(roc_data, aes(x = fpr)) +
      geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), fill = color, alpha = 0.2) +
      geom_line(aes(y = mean_tpr), color = color, size = 1) +
      labs(x = "False Positive Rate", 
           y = "True Positive Rate", 
           title = sprintf("Performance of the %s Model", model_name)) +
      annotate("text", x = 0.75, y = 0.25, 
               label = sprintf("AUC: %.3f (95%% CI: %.3f - %.3f)", auc$mean, auc$ci[1], auc$ci[2]), color = color) +
      theme_minimal(base_size = 14)
  }
  
  # Create plots for RF, SVM, and GLM
  rf_plot <- plot_roc(roc_data$RF, auc_scores$RF, "Random Forest", "red")
  svm_plot <- plot_roc(roc_data$SVM, auc_scores$SVM, "SVM", "blue")
  glm_plot <- plot_roc(roc_data$GLM, auc_scores$GLM, "GLM", "black")
  
  # Save each plot
  ggsave(filename = "Results/Figure 9A.jpg", plot = rf_plot, width = 8, height = 6, dpi = 600)
  ggsave(filename = "Results/Figure 9B.jpg", plot = svm_plot, width = 8, height = 6, dpi = 600)
  ggsave(filename = "Results/Figure 9C.jpg", plot = glm_plot, width = 8, height = 6, dpi = 600)
  
  return(list(rf_plot = rf_plot, svm_plot = svm_plot, glm_plot = glm_plot, auc_scores = auc_scores))
}
# Example usage
result <- MicroRoc(ps = Genexpert_phyloseq, group_var = "Group")
print(result$rf_plot)
print(result$svm_plot)
print(result$glm_plot)
print(result$auc_scores)
```
## **Random Forest model**
```{r, warning=FALSE, message=FALSE}
# Function to estimate model accuracy and generate a confusion matrix table
estimate_accuracy <- function(rf_model) {
  # Extract confusion matrix from the Random Forest model
  confusion_matrix <- as.data.frame(rf_model$confusion)
  
  # Add a new column to calculate the class error
  confusion_matrix$class_error <- round(confusion_matrix$class.error, 3)
  confusion_matrix$Group <- row.names(confusion_matrix)
  
  # Reorder columns for better readability
  confusion_matrix <- dplyr::select(confusion_matrix, Group, everything())
  
  # Calculate the overall accuracy rate of the model
  accuracy_rate <- paste(round(100 - tail(rf_model$err.rate[, 1], 1) * 100, 2), "%", sep = "")
  accuracy_rate_df <- data.frame(ID = "Model Accuracy Rate", Accuracy_Rate = accuracy_rate)
  colnames(accuracy_rate_df) <- c("Random Forest", "Accuracy Rate")
  
  # Create tables for the accuracy rate and confusion matrix
  accuracy_table <- ggpubr::ggtexttable(accuracy_rate_df, rows = NULL)
  confusion_table <- ggpubr::ggtexttable(confusion_matrix, rows = NULL)
  
  # Combine both tables into one display
  combined_tables <- accuracy_table / confusion_table
  
  # Return the combined tables
  return(combined_tables)
}

# Function to extract top important features (bacterial markers) based on Random Forest model
extract_top_features <- function(rf_model, ps, top_features = 20) {
  # Extract feature importance metrics from the Random Forest model
  feature_importance <- as.data.frame(round(randomForest::importance(rf_model), 2))
  
  # Assign feature IDs for better readability
  feature_importance$feature_id <- row.names(feature_importance)
  row.names(feature_importance) <- gsub("feature", "", row.names(feature_importance))
  feature_importance$feature_id <- gsub("feature", "", feature_importance$feature_id)
  
  # Order features by their importance (MeanDecreaseAccuracy) and select top features
  ordered_features <- dplyr::arrange(feature_importance, desc(MeanDecreaseAccuracy))
  top_features_df <- head(ordered_features, n = top_features)
  
  # Extract taxonomy information corresponding to the top features
  taxonomy_df <- as.data.frame(ggClusterNet::vegan_tax(ps))
  relevant_taxonomy <- taxonomy_df[rownames(top_features_df), ]
  
  # Merge top features with their corresponding taxonomy information
  top_features_df <- merge(top_features_df, relevant_taxonomy, by = "row.names", all = FALSE)
  row.names(top_features_df) <- top_features_df$Row.names
  top_features_df$Row.names <- NULL
  
  # Return the dataframe of top features along with their taxonomy
  return(top_features_df)
}

# Function to plot the importance of features and create a polar bar plot
plot_feature_importance <- function(top_features_df) {
  # Plot 1: Importance of features based on MeanDecreaseAccuracy from Random Forest
  importance_plot <- ggplot(top_features_df, aes(x = MeanDecreaseAccuracy, y = reorder(feature_id, MeanDecreaseAccuracy))) +
    geom_point(size = 6, pch = 21, fill = "#9ACD32", color = "#9ACD32") +
    geom_segment(aes(yend = feature_id), xend = 0, size = 3, color = "#9ACD32") +
    geom_label(aes(x = MeanDecreaseAccuracy * 1.1, label = Genus), size = 3)
  
  # Prepare data for the polar plot by arranging and indexing the top features
  top_features_df <- dplyr::arrange(top_features_df, desc(MeanDecreaseAccuracy))
  top_features_df$index <- paste(1:length(top_features_df$feature_id))
  label_angle <- 90 - 360 * (as.numeric(top_features_df$index) - 0.5) / length(top_features_df$feature_id)
  top_features_df$feature_id <- factor(top_features_df$feature_id, levels = top_features_df$feature_id)
  
  # Plot 2: Polar bar plot of feature importance
  polar_plot <- top_features_df %>%
    ggplot(aes(x = factor(feature_id), y = MeanDecreaseAccuracy, label = Genus)) +
    geom_bar(stat = 'identity', position = 'dodge', fill = "blue") +
    geom_text(hjust = 0, angle = label_angle, alpha = 1) +
    coord_polar() +
    theme_void()
  
  # Return the plots
  return(list(importance_plot = importance_plot, polar_plot = polar_plot))
}

# Function to perform recursive feature elimination cross-validation (RFCV) with statistics
run_recursive_feature_cv <- function(otu = NULL, tax = NULL, map = NULL, tree = NULL,
                                     ps = NULL, group = "Group", optimal_features = 20, num_folds = 5) {
  
  # Preprocess the phyloseq object and scale the microbial data
  ps <- ggClusterNet::inputMicro(otu, tax, map, tree, ps, group = group)
  
  # Prepare the OTU table and sample metadata
  otu_table <- as.data.frame(ggClusterNet::vegan_otu(ps))
  sample_metadata <- as.data.frame(phyloseq::sample_data(ps))

  # Set classification labels and clean up column names
  otu_table$group <- factor(sample_metadata$Group)
  colnames(otu_table) <- gsub("-", "_", colnames(otu_table))
  
  # Define feature data by removing the group column
  num_features <- ncol(otu_table) - 1
  feature_data <- otu_table[1:num_features]
  
  # Initial RFCV with a set seed
  set.seed(315)
  rfcv_result <- rfcv(feature_data, otu_table$group, cv.fold = num_folds, scale = "log", step = 0.9)
  
  # Store cross-validation error data for each fold
  error_cv_df <- data.frame(num_features = rfcv_result$n.var, error_rate_1 = rfcv_result$error.cv)
  
  # Repeat RFCV with different seeds to ensure stability
  for (seed in 316:(315 + num_folds - 1)) {
    set.seed(seed)
    rfcv_result <- rfcv(feature_data, otu_table$group, cv.fold = num_folds, scale = "log", step = 0.9)
    error_cv_df <- cbind(error_cv_df, rfcv_result$error.cv)
  }
  
  # Calculate mean, standard deviation, and confidence intervals for error rates
  error_cv_df <- error_cv_df[, -1]  # Remove the num_features column
  colnames(error_cv_df) <- paste('error_rate', 1:num_folds, sep = '_')
  mean_error <- rowMeans(error_cv_df)
  std_error <- apply(error_cv_df, 1, sd)
  
  # Calculate 95% confidence intervals (assuming normal distribution)
  ci_low <- mean_error - 1.96 * (std_error / sqrt(num_folds))
  ci_high <- mean_error + 1.96 * (std_error / sqrt(num_folds))
  
  # Prepare summary data for plotting and reporting
  rfcv_summary <- data.frame(
    num_features = rfcv_result$n.var,
    mean_error = mean_error,
    std_error = std_error,
    ci_low = ci_low,
    ci_high = ci_high
  )
  
  # Transform the data for plotting
  plot_data <- tidyr::gather(rfcv_summary, key = "metric", value = "value", -num_features)
  
 # Generate a plot showing the RFCV results with error bars
rfcv_plot <- ggplot() +
  geom_line(data = plot_data, aes(x = num_features, y = value, group = metric, color = metric), linetype = "dashed") +
  geom_ribbon(aes(x = rfcv_summary$num_features, ymin = rfcv_summary$ci_low, ymax = rfcv_summary$ci_high), fill = "blue", alpha = 0.2) +
  geom_line(aes(x = rfcv_summary$num_features, y = rfcv_summary$mean_error), colour = 'black') +
  coord_trans(x = "log2") +
  scale_x_continuous(breaks = c(1, 2, 5, 10, 20, 30, 50, 100, 200)) +
  labs(title = paste('Cross validation Training set (n =', nrow(otu_table), ')', sep = ''),
       x = 'Number of features', 
       y = 'Cross-validation error rate') +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # Customize title size and position
    axis.title.x = element_text(size = 14),  # Customize x-axis title size
    axis.title.y = element_text(size = 14)   # Customize y-axis title size
  ) +
  annotate("text", x = optimal_features, y = max(rfcv_summary$mean_error), 
           label = paste("optimal = ", optimal_features, sep = ""))

# Return the plot and summary data
return(list(plot = rfcv_plot, summary_data = rfcv_summary))
}

# Main function to run the Random Forest analysis and generate reports and plots
micro_rf_analysis <- function(otu = NULL, tax = NULL, map = NULL, tree = NULL,
                              ps = NULL, group = "Group", top_features = 20, perform_rfcv = FALSE, 
                              rfcv_folds = 5, min_ylim = -1, max_ylim = 5) {
  
  # Preprocess the phyloseq object and scale the microbial data
  ps <- ggClusterNet::inputMicro(otu, tax, map, tree, ps, group = group) %>% ggClusterNet::scale_micro()
  sample_data_df <- as.data.frame(phyloseq::sample_data(ps))
  
  # Prepare OTU table with scaled data and set up Random Forest model
  mapping_df <- as.data.frame(phyloseq::sample_data(ps))
  otu_table <- as.data.frame((ggClusterNet::vegan_otu(ps)))
  colnames(otu_table) <- paste("feature", colnames(otu_table), sep = "")
  otu_table$group <- factor(mapping_df$Group)
  
  # Fit the Random Forest model
  rf_model <- randomForest::randomForest(group ~ ., data = otu_table, importance = TRUE, proximity = TRUE)
  print(rf_model)
  
  # Estimate the accuracy of the model and generate the confusion matrix
  accuracy_table <- estimate_accuracy(rf_model)
  
  # Extract the top important features (bacterial markers)
  top_features_df <- extract_top_features(rf_model, ps, top_features)
  
  # Generate plots for feature importance
  plots <- plot_feature_importance(top_features_df)
  
  # Perform RFCV if requested
  if (perform_rfcv) {
    rfcv_result <- run_recursive_feature_cv(otu = NULL, tax = NULL, map = NULL, tree = NULL, 
                                            ps = ps, group = group, optimal_features = top_features, 
                                            num_folds = rfcv_folds)
    rfcv_plot <- rfcv_result[[1]]
    rfcv_table <- rfcv_result[[2]]
  } else {
    rfcv_plot <- NULL
    rfcv_table <- NULL
  }
  
  # Return the results: importance plot, polar plot, RFCV plot, RFCV table, top features, accuracy table
  return(list(plots$importance_plot, plots$polar_plot, rfcv_plot, rfcv_table, top_features_df, accuracy_table))
}

# Run the Random Forest analysis with specified parameters
result <- micro_rf_analysis(ps = MtbInfectionStatus_phyloseq,
                            group = "Group",
                            top_features = 40, perform_rfcv = TRUE, rfcv_folds = 5,
                            min_ylim = -1, max_ylim = 5)

# Access the generated plots and tables
plot1 <- result[[1]]  # Importance plot
plot2 <- result[[2]]  # Polar plot
plot3 <- result[[3]]  # RFCV plot (if perform_rfcv = TRUE)

combined_plot <- cowplot::plot_grid(plot1, plot2, labels = c("A", "B"))
# Add a title to the combined plot
combined_plot <- cowplot::ggdraw() +
  cowplot::draw_plot(combined_plot, 0, 0, 1, 0.9) +  # Adjust plot position and size
  cowplot::draw_label("Combined Feature Importance and Polar Plot", 
                      x = 0.5, y = 0.95, hjust = 0.5, size = 16)

# Print the combined plot with title
print(combined_plot)


# Save the plots as high-resolution images
ggsave(filename = "Results/Figure 9D.jpg", plot = combined_plot, width = 10, height = 8, dpi = 600)
ggsave(filename = "Results/Figure 9E.jpg", plot = plot3, width = 10, height = 8, dpi = 600)

```


